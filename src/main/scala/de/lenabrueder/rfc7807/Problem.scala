package de.lenabrueder.rfc7807

import play.api.http.Status
import play.api.libs.json.JsonNaming.SnakeCase
import play.api.libs.json.{Json, JsonConfiguration}

/**See https://tools.ietf.org/html/rfc7807#page-3 for more information about this type*/
case class Problem(
    /** A URI reference that identifies the problem type.
      * It should, if dereferenced, provide some human-readable documentation of the problem.
      */
    `type`: String,
    /** A short, human-readable summary of the problem type.*/
    title: String,
    /** The HTTP status code generated by the origin server for this occurrence of the problem.*/
    status: Option[Int] = None,
    /** A human-readable explanation specific to this occurrence of the problem.*/
    detail: Option[String] = None,
    /** A URI reference that identifies the specific occurrence of the problem.
      * It may or may not yield further information if dereferenced.
      */
    instance: Option[String] = None
)

object Problem {
  private implicit val config = JsonConfiguration(SnakeCase)
  implicit val format         = Json.format[Problem]
}

/** A base trait to tell how to generate URLs for problems. Depends on the error code.
  * You can override the returned content type as well if you need to.
  */
trait UrlConfiguration {
  def url(code: String): String
  val problemJsonType: String = "application/problem+json"
}

object UrlConfiguration {

  /** Will by default redirect to httpstatuses.com for HTTP status code explanation. */
  implicit case object DefaultUrlConfiguration extends UrlConfiguration {
    override def url(code: String): String = s"https://httpstatuses.com/$code"
  }

  /** Allows to customize the url used for the `type`, which gets derived from the `status`.
    * Use "%s" to mark where the status code should be pasted.
    */
  case class CustomUrlConfiguration(customUrl: String) extends UrlConfiguration {
    def url(code: String) = customUrl.format(code)
  }
}

/**use this to extend your exceptions to be able to directly convert them to a problem instance*/
trait Problematic {
  def asProblem: Problem
}
trait EasyProblematic extends Problematic {
  def errorCode: String
  def message: Option[String] = None
  def urlConfiguration: UrlConfiguration

  override def asProblem: Problem =
    Problem(`type` = urlConfiguration.url(errorCode), title = message getOrElse "unknown")
}
object Problematic {
  def fromException(ex: Throwable)(implicit urlConfiguration: UrlConfiguration) = new Problematic {
    override def asProblem: Problem = ex match {
      case p: Problematic => p.asProblem
      case _              => Problem(urlConfiguration.url(Status.INTERNAL_SERVER_ERROR.toString), ex.getMessage)
    }
  }
}
